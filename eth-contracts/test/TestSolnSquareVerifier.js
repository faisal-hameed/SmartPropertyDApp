// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var SolnSquareVerifier = artifacts.require('SolnSquareVerifier');
var Verifier = artifacts.require('SquareVerifier');
var Proof = require('../../zokrates/code/square/proof.json');

// let bytecode = compiledContract.contracts['nameContract'].bytecode;
// let gasEstimate = web3.eth.estimateGas({data: bytecode});

contract('SolnSquareVerifier', accounts => {
    let owner = accounts[0];

    let tokenID1 = 1;
    let account_one = accounts[1];
    // Test if a new solution can be added for contract - SolnSquareVerifier
    describe('Test Verification with correct proof', function () {
        beforeEach(async function () {
            let verifier = await Verifier.new({from: owner});
            console.log('Verifier contract : ' + verifier.address);
            this.contract = await SolnSquareVerifier.new(verifier.address, {from: owner});
            console.log('Soln Verifier contract : ' + this.contract.address);
        })

        it('New token can be minted', async function() {
            //console.log('Using Proof : ' + JSON.stringify(Proof));
            let tx = await this.contract.mintNew(
                tokenID1,
                account_one,
                Proof.proof.A,
                Proof.proof.A_p,
                Proof.proof.B,
                Proof.proof.B_p,
                Proof.proof.C,
                Proof.proof.C_p,
                Proof.proof.H,
                Proof.proof.K,
                Proof.input
            , {from : owner}
            );

            // Verify correct event is emitted
            assert.equal(tx.logs[0].event, 'SolutionAdded', 'Transfer event shuold be triggered')

        })

        it('New token cannot be minted twice', async function() {
            //console.log('Using Proof : ' + JSON.stringify(Proof));
            let reverted = false;
            try {
                await this.contract.mintNew(
                    tokenID1,
                    account_one,
                    Proof.proof.A,
                    Proof.proof.A_p,
                    Proof.proof.B,
                    Proof.proof.B_p,
                    Proof.proof.C,
                    Proof.proof.C_p,
                    Proof.proof.H,
                    Proof.proof.K,
                    Proof.input
                , {from : owner}
                );

                let tx = await this.contract.mintNew(
                    tokenID1,
                    account_one,
                    Proof.proof.A,
                    Proof.proof.A_p,
                    Proof.proof.B,
                    Proof.proof.B_p,
                    Proof.proof.C,
                    Proof.proof.C_p,
                    Proof.proof.H,
                    Proof.proof.K,
                    Proof.input
                , {from : owner}
                );
            } catch (e) {
                console.log(e.message)
                reverted = true;
            }

            assert.equal(reverted, true, 'Token cannot be minted twice');

        })

    });
})
